/// <reference types="zen-observable" />
import { ExecutionResult, DocumentNode, GraphQLError } from 'graphql';
import { Cache } from '../cache/core/types/Cache';
import { ApolloCache } from '../cache/core/cache';
import { WatchQueryOptions } from './watchQueryOptions';
import { ObservableQuery } from './ObservableQuery';
import { QueryListener } from './types';
import { NetworkStatus } from './networkStatus';
export declare type QueryStoreValue = Pick<QueryInfo, "variables" | "networkStatus" | "networkError" | "graphQLErrors">;
export declare class QueryInfo {
    private cache;
    listeners: Set<QueryListener>;
    document: DocumentNode | null;
    lastRequestId: number;
    observableQuery: ObservableQuery<any> | null;
    subscriptions: Set<ZenObservable.Subscription>;
    variables?: Record<string, any>;
    networkStatus?: NetworkStatus;
    networkError?: Error;
    graphQLErrors?: ReadonlyArray<GraphQLError>;
    constructor(cache: ApolloCache<any>);
    init(query: {
        document: DocumentNode;
        variables: Record<string, any>;
        isPoll: boolean;
        isRefetch: boolean;
        observableQuery?: ObservableQuery<any>;
        lastRequestId?: number;
    }): this;
    private dirty;
    setDirty(): this;
    private notifyTimeout?;
    private diff;
    setDiff(diff: Cache.DiffResult<any> | null): void;
    getDiff(): Cache.DiffResult<any>;
    private getErrorPolicy;
    notify(): void;
    private shouldNotify;
    stop(): void;
    cancel(): void;
    updateWatch(options: WatchQueryOptions): this;
    markResult(result: ExecutionResult, { fetchPolicy, variables, errorPolicy, }: WatchQueryOptions, allowCacheWrite: boolean, makeReady: boolean): void;
    markError(error: Error): void;
}
//# sourceMappingURL=QueryInfo.d.ts.map